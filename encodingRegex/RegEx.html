<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Dr. Jesse Stewart" />

<meta name="date" content="2025-08-07" />

<title>RegEx (Regular Expressions)</title>

<script src="RegEx_files/header-attrs-2.28/header-attrs.js"></script>
<script src="RegEx_files/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="RegEx_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="RegEx_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="RegEx_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="RegEx_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="RegEx_files/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="RegEx_files/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="RegEx_files/tocify-1.9.1/jquery.tocify.js"></script>
<script src="RegEx_files/navigation-1.1/tabsets.js"></script>
<link href="RegEx_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="RegEx_files/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div id="header">



<h1 class="title toc-ignore">RegEx (Regular Expressions)</h1>
<h4 class="author">Dr. Jesse Stewart</h4>
<h4 class="date">2025-08-07</h4>

</div>


<div id="why-regex" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Why regex?</h1>
<p>Regular expressions (regex) are compact pattern languages for
finding, extracting, and editing strings. In computational linguistics,
we use them to:<br />
- locate morpheme boundaries, glosses, and tier labels;<br />
- convert orthography to IPA;<br />
- search for strings in ELAN;<br />
- pre-clean corpora before NLP.</p>
<p><strong>Base R</strong> uses (<code>grepl</code>, <code>gsub</code>,
<code>gregexpr</code>) and <strong>stringr</strong>
(<code>str_detect</code>, <code>str_extract</code>,
<code>str_match</code>, <code>str_replace</code>). <code>stringr</code>
is often clearer; base gives you full control. The module will primarily
use EditPad Lite, but we will also discuss the R functions.</p>
<pre class="r"><code>library(stringr)</code></pre>
</div>
<div id="introduction" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Introduction</h1>
<p>We’ll be using this file <a
href="Dictionary.txt">dictionary.txt</a></p>
<p>Regular expressions (RegEx) are special strings of text for
describing a specific pattern of interest. RegEx is often used in
computer programming and database management to provide users with a
powerful tool for locating and describing a desired search pattern.
Linguistic programs such as ELAN are equipped with a RegEx search engine
which facilitates searching through large quantities of data (especially
human-annotated data which may contain formatting errors or typos). R is
equipped with RegEx and there are add-ons for Excel. EditPad Lite and
TextWrangler are specifically designed to take full advantage of RegEx.
You can think of regular expressions as your basic search function on
crack. While RegEx often seems daunting at first, this module will
introduce basic RegEx functions step-by-step while providing various
exercises and examples suited for natural language analysis.</p>
<p><strong>Sites for testing RegEx:</strong><br />
- <a href="https://projects.verou.me/regexplained/">RegExp
Playground</a><br />
- <a href="https://www.zytrax.com/tech/web/regex.htm/">Zytrax Tech
Stuff</a><br />
- <a
href="https://www.youtube.com/watch?v=EkluES9Rvak">/Reg(exp){2}lained/:
Demystifying Regular Expressions/</a></p>
</div>
<div id="basic-search" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Basic search</h1>
<p>Basic search functions are integrated into almost every text editor
available (e.g., Notepad). Pressing <code>Control+F</code> (Windows) or
<code>Command+F</code> (Mac) is often the default shortcut key to bring
up the <code>Find</code> or <code>Search</code> function in most text
editors. This search engine is limited to basic searches of keywords,
symbols, delimiters (e.g., tabs, spaces, commas). Other text editors;
more specifically, word processors such as Microsoft Word, have more
advanced search functions.</p>
<p>Word allows a larger variety of search options such as:<br />
- Matching case<br />
- Matching white spaces<br />
- Searching for paragraph markers<br />
- Searching for digits only<br />
- Searching for tabs<br />
- Searching for letters only<br />
- Searching for column breaks<br />
- Searching for text in graphics<br />
- Searching for any character<br />
- Searching for whole words<br />
- ‘Sounds like’ search function</p>
<p>Word also allows you to search for formatting directly (e.g., fonts,
paragraph styles, specific languages, etc.).</p>
</div>
<div id="setting-up-editpad-lite" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Setting up EditPad
Lite</h1>
<p>I find the <code>multi-line search panel</code> easier to work
with.<br />
<img src="RegEx_images/editpad1.jpg" alt="setting up multi-line search" width="300"/><br />
<br><br></p>
<p>Next you’ll want to click on the <code>Regex</code> button and the
<code>magnifying glass</code> button to highlight your matches.<br />
<img src="RegEx_images/editpad2.jpg" alt="setting up multi-line search" width="500"/>
<br><br></p>
<p>The <code>Count Matches</code> button is one of the more useful
functions.<br />
<img src="RegEx_images/editpad3.jpg" alt="setting up multi-line search" width="500"/>
<br><br></p>
<p>As is the <code>Copy</code> function.<br />
<img src="RegEx_images/editpad4.jpg" alt="setting up multi-line search" width="500"/>
<br><br></p>
<p>Also the <code>Replace All</code> function.<br />
<img src="RegEx_images/editpad5.jpg" alt="setting up multi-line search" width="500"/>
<br><br></p>
<p>For Mac, consider one of the following:<br />
<img src="RegEx_images/mac.jpg" alt="setting up multi-line search" width="500"/>
<br><br></p>
<p>You may have to enable <code>grep</code> (Global Regular Expression
Print).<br />
<img src="RegEx_images/mac2.jpg" alt="setting up multi-line search" width="500"/></p>
</div>
<div id="practice-dataset" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Practice Dataset</h1>
<p>We’ll use the following text for our search and regex practice.
Copy/paste it into your text editor or assign it to an object in R.</p>
<div style="color:#00008B">
<p>123456789012345678901234567890123456789012345678901234567890</p>
<p>abcdefghijklmnopqrstuvwxyz1234567890</p>
<p>caaaat</p>
<p>abcdefghijklmnopqrstuvwxyz1234567890</p>
<p>123456789012345678901234567890123456789012345678901234567890</p>
<p>abcdef123456</p>
<p>abc1267</p>
<p>It was a dark and stormy night; the rain fell in torrents — except at
occasional intervals, when it was checked by a violent gust of wind
which swept up the streets (for it is in London that our scene lies),
rattling along the housetops, and fiercely agitating the scanty flame of
the lamps that struggled against the darkness.<br />
-Paul Clifford (1830:1)</p>
<p>ˈhaʊ ˈmʌtʃ ˈwʊd kʊd ə ˈwʊdˌtʃʌk ˈtʃʌk ˈɪf ə ˈwʊdˌtʃʌk ˈkʊd ˈtʃʌk
ˈwʊd</p>
<p>The cat in the hat swung the bat then rolled on the mat after biting
Pat.</p>
<p>The cat in the hat swung the bat then rolled on the mat after biting
Pat whose password is 35at130t.</p>
<p>Mas leñatami traimuna coznagapa.<br />
Nuestro alpaca buenomi sembrangapa.<br />
Ese puertaka puro tablami.<br />
Ese alfombraka bonitowami.<br />
Ese hornota tenichi ese leñawanmi ocupanchi.<br />
Cuanto platotata teninchi comidapak?<br />
Tal vez otro ollo grandita teninguichu?<br />
Ondepita ese piedra cuchillota afilangapaka?<br />
Teniguichu otro kallanata tostangapa tostadota?</p>
<p>The colors green and blue are the same word in language X, while the
colours red and yellow are different. Color is a complicated
concept.</p>
<p>1000000, 1’000.000, 1,000,000</p>
<p>6125487, 7’456.987, 9,789,321</p>
<p>The bomb when booooooooom! The boom was so loud!</p>
<p>BOOM, BOOOOOM, Booom, or BoOoOm</p>
<p>459-1670; 641-6021; 893-5581; 491-9503; 876-9894</p>
<p>boom, booom, boooom, booooom, boooooom, booooooom, boooooooom,
booooooooom</p>
<p>bom, boom, booom, boooom, booooom, boooooom, booooooom, boooooooom,
booooooooom, booooooooooooooooooooooooooooooooooooooooom</p>
<p>The dog ate the cat who chased the rat that ate the Pat’s mat (Pat’s
black mat).</p>
<p>$1,302,928.13; $1’302.928,25; $3’354.144,32</p>
<p>cat, dogs, frog, word, phone, regex, ling</p>
<p>cat bear ape dog tiger monkey donkey badger</p>
<p>left hand; right hand; Left hand; Right hand; hand; left right;
handed; left handed</p>
<p>459-1670; 641.6021; 893 5581; 491-9503; 876.9894; 555 2323; 877-5544;
899.1000; 456 2999; 123-4567</p>
<p>(360)459-1670; 641.6021; 8935581; 491-9503; 876.9894; 555 2323;
877-5544; 899.1000; (323)456 2999; 123-4567</p>
<p>1.) #d4d4d2<br />
2.) #1a1a1a<br />
3.) #ed20ba<br />
4.) #4c8bff<br />
5.) #3cff00</p>
<p>1.) #15DC1490242AB67B<br />
2.) #whatsthatsmell<br />
3.) #mr20lb<br />
4.) #15DC1490242AB67B”</p>
</div>
</div>
<div id="basic-search-non-regex" class="section level1" number="6">
<h1><span class="header-section-number">6</span> Basic Search
(non-Regex)</h1>
<ol style="list-style-type: decimal">
<li>Search for: <code>a</code><br />
</li>
<li>Search for: <code>at</code><br />
</li>
<li>Search for: <code>kaaaat</code><br />
</li>
<li>Search for: <code>a/t</code><br />
</li>
<li>Search for: <code>a539t</code></li>
</ol>
<p>This is equivalent to using <code>Ctrl+F</code> (Windows) or
<code>Command+F</code> (Mac) in a text editor—no special pattern rules,
just literal string matches.</p>
<hr />
</div>
<div id="brackets-ranges-and-negation" class="section level1"
number="7">
<h1><span class="header-section-number">7</span> Brackets, Ranges, and
Negation</h1>
<p><strong>Brackets</strong> match any single character inside them.</p>
<table>
<thead>
<tr class="header">
<th align="left">Pattern</th>
<th align="left">What it matches</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>[35]</code></td>
<td align="left">any single <code>3</code> or <code>5</code></td>
</tr>
<tr class="even">
<td align="left"><code>[abc123]</code></td>
<td align="left">any <code>a</code>, <code>b</code>, <code>c</code>,
<code>1</code>, <code>2</code>, or <code>3</code></td>
</tr>
<tr class="odd">
<td align="left"><code>[a]</code></td>
<td align="left">just the lowercase letter <code>a</code></td>
</tr>
</tbody>
</table>
<p><strong>Ranges</strong> use a dash inside brackets to match a
span.</p>
<table>
<thead>
<tr class="header">
<th align="left">Pattern</th>
<th align="left">Matches</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>[a-d]</code></td>
<td align="left"><code>a</code>, <code>b</code>, <code>c</code>,
<code>d</code></td>
</tr>
<tr class="even">
<td align="left"><code>[1-5]</code></td>
<td align="left"><code>1</code> through <code>5</code></td>
</tr>
<tr class="odd">
<td align="left"><code>[a-c0-2]</code></td>
<td align="left"><code>a</code>, <code>b</code>, <code>c</code>,
<code>0</code>, <code>1</code>, <code>2</code></td>
</tr>
</tbody>
</table>
<p><strong>Negation</strong>: <code>[^ ]</code> matches anything
<em>except</em> the characters inside.</p>
<table>
<thead>
<tr class="header">
<th align="left">Pattern</th>
<th align="left">Matches anything except…</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>[^35]</code></td>
<td align="left">3 or 5</td>
</tr>
<tr class="even">
<td align="left"><code>[^abc123]</code></td>
<td align="left">a, b, c, 1, 2, 3</td>
</tr>
<tr class="odd">
<td align="left"><code>[^1-5]</code></td>
<td align="left">digits 1–5</td>
</tr>
</tbody>
</table>
<p><strong>Vowel patterns</strong>:</p>
<ul>
<li><code>a[eiouy]</code> → diphthongs starting with
<code>a</code><br />
</li>
<li><code>[aeiouy][aeiouy]</code> → any vowel sequence (note: includes
<code>ee</code>, which is not a diphthong)<br />
</li>
<li><code>[a-z]ʊd</code> → words in IPA ending with ʊd (words rhyming
with e.g., <code>would</code>)</li>
<li><code>[^c]at</code> → rhymes with <code>cat</code> but not
<code>cat</code> itself</li>
</ul>
<blockquote>
<p><strong>Note:</strong> In real-world text processing,
<em>practicality is better than precision</em>—don’t overengineer a
perfect regex if a simpler one is good enough for the task.</p>
</blockquote>
</div>
<div id="position-anchors" class="section level1" number="8">
<h1><span class="header-section-number">8</span> Position (Anchors)</h1>
<p>The following meta characters are used to indicate that you want your
search string to only target values at the <strong>beginning</strong> or
<strong>end</strong> of a string.</p>
<ul>
<li><strong><code>^</code></strong> (caret) <strong>outside</strong> of
a pair of brackets: locate strings at the beginning of a line or
string.<br />
</li>
<li><strong><code>$</code></strong> (dollar sign)
<strong>outside</strong> of a pair of brackets: locate strings at the
end of a line or string.</li>
</ul>
<p>In a single-line search, these work up until a line break
(<code>\n</code>).</p>
<p>Examples:</p>
<table>
<colgroup>
<col width="59%" />
<col width="40%" />
</colgroup>
<thead>
<tr class="header">
<th>Pattern</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>^[I]</code></td>
<td>Paragraph-initial <code>I</code> or words starting with
<code>I</code> (e.g., <code>It</code>, <code>It was</code>)</td>
</tr>
<tr class="even">
<td><code>^[I]t was</code></td>
<td>Match specifically “It was” at the start of a paragraph or line</td>
</tr>
<tr class="odd">
<td><code>^[-]</code></td>
<td>Paragraph-initial dash</td>
</tr>
<tr class="even">
<td><code>[.]$</code></td>
<td>End period</td>
</tr>
<tr class="odd">
<td><code>ss[.]$</code></td>
<td>String ending with “ss.”</td>
</tr>
<tr class="even">
<td><code>[)]$</code></td>
<td>Final closed bracket <code>)</code> at the end of a string</td>
</tr>
<tr class="odd">
<td><code>[.?!]$</code></td>
<td>End punctuation useful for locating the end of annotations or
sentences</td>
</tr>
</tbody>
</table>
<hr />
</div>
<div id="special-characters" class="section level1" number="9">
<h1><span class="header-section-number">9</span> Special Characters</h1>
<ul>
<li><strong><code>.</code></strong> (period) outside of brackets:
matches <strong>any</strong> single character except a line break.
<ul>
<li>Example: <code>....</code> → matches any four characters in a
row.</li>
<li>Example: <code>.[lL]</code> → any character followed by
<code>l</code> or <code>L</code>.</li>
</ul></li>
</ul>
<hr />
<div id="zero-or-one-occurrence" class="section level2" number="9.1">
<h2><span class="header-section-number">9.1</span> <code>?</code> — Zero
or one occurrence</h2>
<p>Matches when the preceding character occurs 0 or 1 time only.</p>
<ul>
<li>Example: <code>[Cc]olou?r</code> → matches “color” or “colour”.</li>
<li>Example: <code>1'?'?,?000\\.?,?000</code> → matches “1,000,000” in
both American and Spanish number formats.</li>
<li>Example: <code>[0-9]{1}'?'?,?[0-9]{3}\\.?,?[0-9]{3}</code> → matches
“6125487”, “7’456.987”, “9,789,321”.</li>
</ul>
<hr />
</div>
<div id="zero-or-more-occurrences" class="section level2" number="9.2">
<h2><span class="header-section-number">9.2</span> <code>*</code> — Zero
or more occurrences</h2>
<p>Matches when the preceding character occurs 0 to infinite times.</p>
<ul>
<li>Example: <code>[bB]o*m</code> → matches “bm”, “bom”, “boom”,
“booooom”, etc. (includes zero <code>o</code>).</li>
</ul>
<hr />
</div>
<div id="one-or-more-occurrences" class="section level2" number="9.3">
<h2><span class="header-section-number">9.3</span> <code>+</code> — One
or more occurrences</h2>
<p>Like <code>*</code>, but requires at least one occurrence.</p>
<ul>
<li>Example: <code>[bB]o+m</code> → matches “boom”, “boooom” but
<strong>not</strong> “bm”.</li>
<li>Example: <code>[bB]o+m[^a-z]</code> → matches “boom” but not “bomb”
or “bmb”.</li>
<li>Example: <code>[bB][oO]+[mM][^a-z]</code> → matches “BOOM”,
“BOOOOOM”, “Booom”, “BoOoOm”.</li>
</ul>
<hr />
</div>
<div id="n-exact-number-of-occurrences" class="section level2"
number="9.4">
<h2><span class="header-section-number">9.4</span> <code>{n}</code> —
Exact number of occurrences</h2>
<p>Define the exact repetition count of the preceding character.</p>
<ul>
<li>Example: <code>[bB][oO]{2}[mM][^a-z]</code> → matches “boom” with
<strong>only</strong> two <code>o</code>’s.</li>
<li>Example: <code>[0-9]{3}[-. ][0-9]{4}</code> → matches phone numbers
like “459-1670”, “641.6021”, “893 5581”.</li>
</ul>
<hr />
</div>
<div id="nm-range-of-occurrences" class="section level2" number="9.5">
<h2><span class="header-section-number">9.5</span> <code>{n,m}</code> —
Range of occurrences</h2>
<p>Define a lower and upper bound for repetitions.</p>
<ul>
<li>Example: <code>[bB][oO]{2,6}[mM][^a-z]</code> → matches “boom”
through “boooooom”, but <strong>not</strong> “booooooom” or longer.</li>
</ul>
<hr />
</div>
<div id="n-lower-bound-only" class="section level2" number="9.6">
<h2><span class="header-section-number">9.6</span> <code>{n,}</code> —
Lower bound only</h2>
<p>Define the minimum number of repetitions, with no upper limit.</p>
<ul>
<li>Example: <code>[bB][oO]{2,}[mM][^a-z]</code> → matches “boom”,
“booom”, all the way up to “booooooooooooooooooooooom”, but
<strong>not</strong> “bom”.</li>
</ul>
</div>
</div>
<div id="meta-character-to-literal-character-escaping-meta-characters"
class="section level1" number="10">
<h1><span class="header-section-number">10</span> Meta Character to
Literal Character (Escaping Meta Characters)</h1>
<p>Meta characters need to be escaped (with a backslash) when you want
them to be treated <strong>literally</strong>.</p>
<table>
<thead>
<tr class="header">
<th>Meta</th>
<th>Literal</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>.</code></td>
<td><code>\.</code></td>
</tr>
<tr class="even">
<td><code>^</code></td>
<td><code>\^</code></td>
</tr>
<tr class="odd">
<td><code>?</code></td>
<td><code>\?</code></td>
</tr>
<tr class="even">
<td><code>$</code></td>
<td><code>\$</code></td>
</tr>
<tr class="odd">
<td><code>[</code></td>
<td><code>\[</code></td>
</tr>
<tr class="even">
<td><code>|</code></td>
<td><code>\|</code></td>
</tr>
<tr class="odd">
<td><code>]</code></td>
<td><code>\]</code></td>
</tr>
<tr class="even">
<td><code>(</code></td>
<td><code>\(</code></td>
</tr>
<tr class="odd">
<td><code>)</code></td>
<td><code>\)</code></td>
</tr>
<tr class="even">
<td><code>+</code></td>
<td><code>\+</code></td>
</tr>
<tr class="odd">
<td><code>*</code></td>
<td><code>\*</code></td>
</tr>
<tr class="even">
<td><code>{</code></td>
<td><code>\{</code></td>
</tr>
<tr class="odd">
<td><code>}</code></td>
<td><code>\}</code></td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong> to capture anything inside literal
parentheses, use <code>\(.*\)</code> (the parentheses are escaped).</p>
<ul>
<li>Pattern (engine): <code>\(.*\)</code><br />
</li>
<li>Pattern (R string): <code>"\\(.*\\)"</code></li>
</ul>
<p>Monetary values (≤ 9,999,999.99) with different thousands/decimal
separators:</p>
<ul>
<li>Pattern (engine):
<code>\$[0-9]{1}[',.’][0-9]{3}[',.’][0-9]{3}[.,’][0-9]{2}</code><br />
</li>
<li>Pattern (R string):
<code>"\\$[0-9]{1}['.,’][0-9]{3}['.,’][0-9]{3}[.,’][0-9]{2}"</code></li>
</ul>
<pre class="r"><code>x &lt;- c(&quot;$1,302,928.13&quot;, &quot;$1’302.928,25&quot;, &quot;$3’354.144,32&quot;, &quot;$12.34&quot;)
pat_money &lt;- &quot;\\$[0-9]{1}[&#39;.,’][0-9]{3}[&#39;.,’][0-9]{3}[.,’][0-9]{2}&quot;
stringr::str_detect(x, pat_money)</code></pre>
<pre><code>## [1]  TRUE  TRUE  TRUE FALSE</code></pre>
</div>
<div id="character-class-abbreviations" class="section level1"
number="11">
<h1><span class="header-section-number">11</span> Character Class
Abbreviations</h1>
<p>Character classes allow you to match specific sets of characters
without listing them all individually.<br />
R uses <strong>double backslashes</strong> (<code>\\</code>) in string
patterns because the first backslash escapes the second in the R
string,<br />
and the second is passed to the regex engine.</p>
<table>
<colgroup>
<col width="17%" />
<col width="55%" />
<col width="27%" />
</colgroup>
<thead>
<tr class="header">
<th>Abbreviation</th>
<th>Matches</th>
<th>Example Matches</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>\w</code></td>
<td>Any letter, digit, or underscore (<code>a–z</code>,
<code>A–Z</code>, <code>0–9</code>, <code>_</code>)</td>
<td><code>word_1</code>, <code>A3</code></td>
</tr>
<tr class="even">
<td><code>\d</code></td>
<td>Any digit (<code>0–9</code>)</td>
<td><code>5</code>, <code>42</code></td>
</tr>
<tr class="odd">
<td><code>\s</code></td>
<td>Any whitespace (space, tab, line break)</td>
<td><code>" "</code>, <code>"\t"</code>, <code>"\n"</code></td>
</tr>
<tr class="even">
<td><code>\b</code></td>
<td>Word boundary</td>
<td>Between <code>cat</code> and space in <code>"cat dog"</code></td>
</tr>
</tbody>
</table>
<p><strong>Negative (uppercase) versions:</strong></p>
<table>
<colgroup>
<col width="17%" />
<col width="55%" />
<col width="27%" />
</colgroup>
<thead>
<tr class="header">
<th>Abbreviation</th>
<th>Matches anything <strong>except</strong>…</th>
<th>Example Matches</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>\W</code></td>
<td>Anything that is not <code>a–z</code>, <code>A–Z</code>,
<code>0–9</code>, <code>_</code></td>
<td><code>!</code>, <code>@</code>, space</td>
</tr>
<tr class="even">
<td><code>\D</code></td>
<td>Anything that is not a digit</td>
<td><code>a</code>, <code>%</code>, space</td>
</tr>
<tr class="odd">
<td><code>\S</code></td>
<td>Anything that is not whitespace</td>
<td><code>a</code>, <code>3</code>, <code>!</code></td>
</tr>
<tr class="even">
<td><code>\B</code></td>
<td>Anything that is not a word boundary</td>
<td>Between <code>c</code> and <code>a</code> in <code>"cat"</code></td>
</tr>
</tbody>
</table>
<hr />
<div id="examples" class="section level2" number="11.1">
<h2><span class="header-section-number">11.1</span> Examples</h2>
<pre class="r"><code>library(stringr)

txt &lt;- c(
  &quot;word&quot;, 
  &quot;word.&quot;, 
  &quot;  space&quot;, 
  &quot;1234&quot;, 
  &quot;no_space&quot;, 
  &quot;mid-day&quot;
)

# Four-letter words using explicit letters
stringr::str_detect(txt, &quot;\\b[a-zA-Z]{4}\\b&quot;)</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE FALSE FALSE FALSE</code></pre>
<pre class="r"><code># Four-letter words using \w (includes digits/underscore)
stringr::str_detect(txt, &quot;\\b\\w{4}\\b&quot;)</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE  TRUE FALSE FALSE</code></pre>
<pre class="r"><code># Detect any digit
stringr::str_detect(txt, &quot;\\d&quot;)</code></pre>
<pre><code>## [1] FALSE FALSE FALSE  TRUE FALSE FALSE</code></pre>
<pre class="r"><code># Detect any whitespace
stringr::str_detect(txt, &quot;\\s&quot;)</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE FALSE FALSE FALSE</code></pre>
<pre class="r"><code># Detect non-digits
stringr::str_detect(txt, &quot;\\D&quot;)</code></pre>
<pre><code>## [1]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE</code></pre>
<pre class="r"><code># Detect word boundaries before/after &#39;word&#39;
stringr::str_detect(txt, &quot;\\bword\\b&quot;)</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE FALSE FALSE FALSE</code></pre>
</div>
<div id="equivalences" class="section level2" number="11.2">
<h2><span class="header-section-number">11.2</span> Equivalences</h2>
<p>Four-letter words:</p>
<p>Pattern (engine): <code>\b[a-zA-Z]{4}\b</code><br />
Pattern (engine): <code>\b\w{4}\b</code><br />
R strings: <code>"\\b[a-zA-Z]{4}\\b"</code>,
<code>"\\b\\w{4}\\b"</code></p>
</div>
</div>
<div id="or-and-grouping" class="section level1" number="12">
<h1><span class="header-section-number">12</span> OR (<code>|</code>)
and Grouping</h1>
<p>The <strong>OR</strong> meta character (<code>|</code>) allows you to
search for one pattern <strong>or</strong> another.<br />
Parentheses <code>()</code> are used to group expressions.</p>
<p><strong>Syntax:</strong>
<code>(expression1|expression2|expression3)</code></p>
<p><strong>Examples:</strong><br />
- <code>(cat|dog|monkey)</code> → matches either <code>"cat"</code>,
<code>"dog"</code>, or <code>"monkey"</code>.<br />
- <code>([lL]eft |[rR]ight )hand\b</code> → matches
<code>"left hand"</code>, <code>"Right hand"</code>,
<code>"Left hand"</code>, <code>"right hand"</code>, but not
<code>"left right"</code> or <code>"left handed"</code>.</p>
<pre class="r"><code>library(stringr)

hands &lt;- c(
  &quot;left hand&quot;, &quot;right hand&quot;, &quot;Left hand&quot;, &quot;Right hand&quot;,
  &quot;hand&quot;, &quot;left right&quot;, &quot;handed&quot;, &quot;left handed&quot;
)

stringr::str_detect(hands, &quot;([lL]eft |[rR]ight )hand\\b&quot;)</code></pre>
<pre><code>## [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE</code></pre>
<div id="phone-numbers-with-or" class="section level2" number="12.1">
<h2><span class="header-section-number">12.1</span> Phone Numbers with
OR</h2>
<p>Sometimes you want to match multiple valid formats for phone
numbers.<br />
The <strong>OR</strong> meta character (<code>|</code>) lets you combine
patterns into one expression.</p>
<p><strong>Example:</strong></p>
<ul>
<li>Base pattern: <code>[\\d]{3}[-. ][\\d]{4}</code> → matches numbers
like:
<ul>
<li><code>459-1670</code><br />
</li>
<li><code>641.6021</code><br />
</li>
<li><code>893 5581</code></li>
</ul></li>
<li>Adding 7-digit numbers (no separator):<br />
<code>([\\d]{3}[-. ][\\d]{4}|[\\d]{7})</code></li>
</ul>
<pre class="r"><code>library(stringr)

phones &lt;- c(
  &quot;459-1670&quot;,  # dash
  &quot;641.6021&quot;,  # period
  &quot;893 5581&quot;,  # space
  &quot;4919503&quot;,   # 7 digits, no separator
  &quot;8769894&quot;,   # 7 digits, no separator
  &quot;123-4567&quot;   # dash
)

# Pattern for ###-#### OR #######
pat_phone_or &lt;- &quot;([0-9]{3}[-. ][0-9]{4}|[0-9]{7})&quot;

stringr::str_detect(phones, pat_phone_or)</code></pre>
<pre><code>## [1] TRUE TRUE TRUE TRUE TRUE TRUE</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>[0-9]{3}</code> → exactly three digits.<br />
</li>
<li><code>[-. ]</code> → a dash (<code>-</code>), period
(<code>.</code>), or space (<code></code>) as the separator.<br />
</li>
<li><code>[0-9]{4}</code> → exactly four digits.<br />
</li>
<li><code>|</code> → logical OR, meaning the engine will try the pattern
on the left <strong>or</strong> the pattern on the right.<br />
</li>
<li><code>[0-9]{7}</code> → exactly seven digits in a row with
<strong>no</strong> separators.</li>
</ul>
<p>This pattern ensures that the regex will match either: 1. Three
digits, followed by a dash/period/space, followed by four digits;
<strong>or</strong> 2. Seven digits in a row.</p>
<hr />
<p><strong>Test Example in R:</strong></p>
<pre class="r"><code>phones &lt;- c(
  &quot;459-1670&quot;,  # matches format 1
  &quot;641.6021&quot;,  # matches format 1
  &quot;893 5581&quot;,  # matches format 1
  &quot;4919503&quot;,   # matches format 2
  &quot;8769894&quot;,   # matches format 2
  &quot;123-4567&quot;,  # matches format 1
  &quot;12-34567&quot;   # does NOT match
)

pat_phone_or &lt;- &quot;([0-9]{3}[-. ][0-9]{4}|[0-9]{7})&quot;
stringr::str_detect(phones, pat_phone_or)</code></pre>
<pre><code>## [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE</code></pre>
</div>
<div id="optional-separator-including-nothing" class="section level2"
number="12.2">
<h2><span class="header-section-number">12.2</span> Optional Separator
(Including “Nothing”)</h2>
<p>Sometimes the separator between number groups may be a dash, period,
space — or nothing at all.<br />
We can allow this flexibility using an <strong>OR group</strong> that
also includes an empty option.</p>
<p><strong>Pattern:</strong> [0-9]{3}(-|.| |)[0-9]{4}</p>
<p><strong>Explanation:</strong> - <code>[0-9]{3}</code> → exactly three
digits. - <code>(-|\.| |)</code> → dash (<code>-</code>), period
(<code>.</code>), space (<code></code>), <strong>or nothing</strong>
(the empty option after the last <code>|</code>). -
<code>[0-9]{4}</code> → exactly four digits.</p>
<pre class="r"><code>library(stringr)

phones2 &lt;- c(
  &quot;459-1670&quot;,  # dash
  &quot;641.6021&quot;,  # period
  &quot;893 5581&quot;,  # space
  &quot;4919503&quot;,   # no separator
  &quot;8769894&quot;,   # no separator
  &quot;4591670&quot;,   # no separator
  &quot;459--1670&quot;  # invalid (double dash)
)

# Match 3 digits + optional separator + 4 digits
pat_opt_sep &lt;- &quot;^[0-9]{3}(-|\\.| |)[0-9]{4}$&quot;

stringr::str_detect(phones2, pat_opt_sep)</code></pre>
<pre><code>## [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE</code></pre>
<p><strong>Notes:</strong> The empty alternative in the group
<code>(-|\.| |)</code> is what allows “nothing” as a valid option. In R
strings, the period <code>.</code> must be escaped as <code>\\</code>.
to mean a literal period rather than “any character”.</p>
</div>
</div>
<div id="hex-colour-codes" class="section level1" number="13">
<h1><span class="header-section-number">13</span> HEX Colour Codes</h1>
<p>A HEX colour code is a string starting with <code>#</code> followed
by exactly six hexadecimal characters. Valid characters are digits
<code>0–9</code> and letters <code>a–f</code> (case-insensitive).</p>
<hr />
<div id="overly-broad-patterns-many-false-positives"
class="section level2" number="13.1">
<h2><span class="header-section-number">13.1</span> Overly Broad
Patterns (Many False Positives)</h2>
<p>If we use patterns that are too general, we will match many unwanted
strings.</p>
<p>Examples of overly broad patterns: - <code>#.+</code> → matches any
<code>#</code> followed by one or more characters. - <code>\w.+</code> →
matches any word character followed by one or more characters. -
<code>#[a-z0-9].+</code> → matches <code>#</code> followed by a
letter/digit, then anything.</p>
<pre class="r"><code>library(stringr)

hexes &lt;- c(
  &quot;#d4d4d2&quot;,&quot;#1a1a1a&quot;,&quot;#ed20ba&quot;,&quot;#4c8bff&quot;,&quot;#3cff00&quot;,
  &quot;#15DC1490242AB67B&quot;,&quot;#whatsthatsmell&quot;,&quot;#mr20lb&quot;,
  &quot;#abc&quot;,&quot;#ABCDEF1&quot;, &quot;#1234567&quot;
)

#Note that there are 3 patterns here
broad_patterns &lt;- c(&quot;#.+&quot;,&quot;\\w.+&quot;,&quot;#[a-z0-9].+&quot;)

#lapply is like a for loop and iterates each pattern over each item in the hexes string
lapply(broad_patterns, function(i) stringr::str_detect(hexes, i))</code></pre>
<pre><code>## [[1]]
##  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
## 
## [[2]]
##  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
## 
## [[3]]
##  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE</code></pre>
<p>FYI the <code>for loop</code> equivlant would be:</p>
<pre class="r"><code>#The for loop equivalant would be:
for (i in broad_patterns) {
  print(stringr::str_detect(hexes, i))
}</code></pre>
<pre><code>##  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
##  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
##  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE</code></pre>
</div>
<div id="restrict-to-exactly-six-characters-after"
class="section level2" number="13.2">
<h2><span class="header-section-number">13.2</span> Restrict to Exactly
Six Characters After <code>#</code></h2>
<p>If we know that a valid HEX colour code contains exactly six
characters after the <code>#</code>,<br />
we can use a pattern with a <strong>quantifier</strong> to enforce this
rule.</p>
<p><strong>Pattern:</strong> <code>#.{6}$</code></p>
<p><strong>Explanation:</strong> - <code>#</code> → literal hash symbol.
- <code>.</code> → any character except a newline. - <code>{6}</code> →
exactly six occurrences. - <code>$</code> → end of the line</p>
<p>This pattern will remove some false positives (e.g.,
<code>#abc</code>, <code>#1234567</code>) but will still allow invalid
characters like <code>g</code> or <code>z</code>.</p>
<pre class="r"><code>library(stringr)

hexes &lt;- c(
  &quot;#d4d4d2&quot;,&quot;#1a1a1a&quot;,&quot;#ed20ba&quot;,&quot;#4c8bff&quot;,&quot;#3cff00&quot;,
  &quot;#15DC1490242AB67B&quot;,&quot;#whatsthatsmell&quot;,&quot;#mr20lb&quot;,
  &quot;#abc&quot;,&quot;#ABCDEF1&quot;, &quot;#12345678&quot;)

stringr::str_detect(hexes, &quot;#.{6}$&quot;)</code></pre>
<pre><code>##  [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE</code></pre>
</div>
<div id="restrict-to-valid-hex-characters-only" class="section level2"
number="13.3">
<h2><span class="header-section-number">13.3</span> Restrict to Valid
Hex Characters Only</h2>
<p>To ensure the pattern matches <strong>only</strong> valid HEX colour
codes,<br />
we need to restrict the allowed characters to hexadecimal digits:<br />
<code>0–9</code> and <code>a–f</code> (case-insensitive).</p>
<hr />
<p><strong>Lowercase only:</strong> <code>#[a-f\d]{6}</code></p>
<ul>
<li><code>a-f</code> → lowercase hexadecimal letters.</li>
<li><code>\d</code> → digits <code>0–9</code>.</li>
<li><code>{6}</code> → exactly six characters.</li>
</ul>
<p><strong>Case-insensitive (upper and lower case):</strong>
<code>#[A-Fa-f0-9]{6}</code></p>
<ul>
<li><code>A-F</code> → uppercase hexadecimal letters.</li>
<li><code>a-f</code> → lowercase hexadecimal letters.</li>
<li><code>0-9</code> → digits.</li>
<li><code>$</code> → end of the line.</li>
</ul>
<hr />
<p><strong>In R:</strong></p>
<pre class="r"><code>library(stringr)

pat_hex_lower &lt;- &quot;^#[a-f0-9]{6}$&quot;
pat_hex_any   &lt;- &quot;^#[A-Fa-f0-9]{6}$&quot;

hexes &lt;- c(
  &quot;#d4d4d2&quot;,&quot;#1a1a1a&quot;,&quot;#ed20ba&quot;,&quot;#4c8bff&quot;,&quot;#3cff00&quot;,
  &quot;#15DC1490242AB67B&quot;,&quot;#whatsthatsmell&quot;,&quot;#mr20lb&quot;,
  &quot;#abc&quot;,&quot;#ABCDEF1&quot;
)

data.frame(
  hex        = hexes,
  lower_only = stringr::str_detect(hexes, pat_hex_lower),
  any_case   = stringr::str_detect(hexes, pat_hex_any)
)</code></pre>
<pre><code>##                  hex lower_only any_case
## 1            #d4d4d2       TRUE     TRUE
## 2            #1a1a1a       TRUE     TRUE
## 3            #ed20ba       TRUE     TRUE
## 4            #4c8bff       TRUE     TRUE
## 5            #3cff00       TRUE     TRUE
## 6  #15DC1490242AB67B      FALSE    FALSE
## 7    #whatsthatsmell      FALSE    FALSE
## 8            #mr20lb      FALSE    FALSE
## 9               #abc      FALSE    FALSE
## 10          #ABCDEF1      FALSE    FALSE</code></pre>
<p><strong>Notes:</strong> Anchors ^ and $ ensure the pattern matches
the entire string, not just part of it.<br />
This eliminates false positives like #ABCDEF1 (too long) or #GHIJKL
(invalid characters).</p>
</div>
<div id="avoid-partial-matches-using-word-boundaries"
class="section level2" number="13.4">
<h2><span class="header-section-number">13.4</span> Avoid Partial
Matches Using Word Boundaries</h2>
<p>Even with the correct six-character HEX pattern, we may still
accidentally match part of a longer string.<br />
For example, in <code>#abc12345</code>, the first seven characters
contain a valid six-character sequence, but it’s part of a longer
token.</p>
<p>To prevent this, we can use the <strong>word boundary</strong> meta
character <code>\b</code> at the end of the pattern.</p>
<p><strong>Pattern:</strong> <code>#[A-Fa-f0-9]{6}\b</code></p>
<p><strong>Explanation:</strong> - <code>#</code> → literal hash. -
<code>[A-Fa-f0-9]{6}</code> → exactly six valid hex characters
(case-insensitive). - <code>\b</code> → word boundary ensures the match
ends cleanly (not in the middle of a larger word).</p>
<hr />
<p><strong>In R:</strong></p>
<pre class="r"><code>library(stringr)

hexes &lt;- c(
  &quot;#d4d4d2&quot;,&quot;#1a1a1a&quot;,&quot;#ed20ba&quot;,&quot;#4c8bff&quot;,&quot;#3cff00&quot;,
  &quot;#15DC1490242AB67B&quot;,&quot;#whatsthatsmell&quot;,&quot;#mr20lb&quot;,
  &quot;#abc&quot;,&quot;#ABCDEF1&quot;
)

stringr::str_detect(hexes, &quot;^#[A-Fa-f0-9]{6}\\b$&quot;)</code></pre>
<pre><code>##  [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE</code></pre>
<p><strong>Notes:</strong></p>
<ul>
<li><p><code>\b</code> matches a position between a word character and a
non-word character.</p></li>
<li><p>Anchors <code>^</code> and <code>$</code> ensure the entire
string is the hex code, while <code>\b</code> is helpful if matching
inside larger text blocks where the code might be followed by
punctuation or spaces.</p></li>
</ul>
</div>
</div>
<div id="worked-example-money-with-shorthand-classes"
class="section level1" number="14">
<h1><span class="header-section-number">14</span> Worked Example: Money
with Shorthand Classes</h1>
<p>Shorthand character classes can make patterns more concise.<br />
Here we’ll match monetary values like <code>$1,302,928.13</code> that
use different thousands and decimal separators.</p>
<hr />
<p><strong>Pattern 1 — Using <code>\d</code> (digit shorthand):</strong>
<code>\$[\d]{1}['.,’][\d]{3}['.,’][\d]{3}[.,][\d]{2}</code></p>
<p><strong>Pattern 2 — Using explicit digit range
<code>[0-9]</code>:</strong>
<code>$[0-9]{1}['.,’][0-9]{3}['.,’][0-9]{3}[.,][0-9]{2}</code></p>
<hr />
<p><strong>Explanation:</strong> - <code>\$</code> → literal dollar sign
(escaped). - <code>[\d]{1}</code> → exactly one digit. -
<code>['.,]</code> → thousands separator: apostrophe, comma, or period.
- <code>[\d]{3}</code> → exactly three digits. - Repeat the separator +
3 digits for millions and thousands groups. - <code>[.,]</code> →
decimal separator: period or comma. - <code>[\d]{2}</code> → exactly two
decimal digits.</p>
<hr />
<p><strong>In R:</strong></p>
<pre class="r"><code>library(stringr)

money_values &lt;- c(
  &quot;$1,302,928.13&quot;,
  &quot;$1’302.928,25&quot;,
  &quot;$3’354.144,32&quot;,
  &quot;$12.34&quot;
)

pat_money_short &lt;- &quot;\\$\\d{1}[&#39;.,’]\\d{3}[&#39;.,’]\\d{3}[.,]\\d{2}&quot;

data.frame(
  value  = money_values,
  detect = stringr::str_detect(money_values, pat_money_short)
)</code></pre>
<pre><code>##           value detect
## 1 $1,302,928.13   TRUE
## 2 $1’302.928,25   TRUE
## 3 $3’354.144,32   TRUE
## 4        $12.34  FALSE</code></pre>
<p><strong>Notes:</strong> The shorthand s easier to read, but [0-9] is
more explicit and behaves the same.<br />
This pattern works for both US (1,302,928.13) and European/Latin
American formats (1’302.928,25).</p>
</div>
<div id="regex-in-the-real-world" class="section level1" number="15">
<h1><span class="header-section-number">15</span> RegEx in the real
world</h1>
<div id="elan" class="section level2" number="15.1">
<h2><span class="header-section-number">15.1</span> ELAN</h2>
<p>We’ll be using ELAN for this demo.<br />
<img src="RegEx_images/elan.jpg" alt="ELAN icon" width="75"/></p>
<p>Download the following files:<br />
<a href="RegEx_files/ASLSample.eaf">EAF file</a><br />
<a href="RegEx_files/---.---">Video</a></p>
<p>The following was used, in part, during the publication of this
paper:<br />
<img src="RegEx_images/SL_paper.jpg" alt="A Quantitative analysis of Sign lengthening in ASL" width="500"/><br />
<a
href="https://www.jbe-platform.com/content/journals/10.1075/sll.17.1.04ste">Paper</a></p>
<p><img src="RegEx_images/Elan_screenshot.jpg" alt="ELAN Screenshot" width="500"/></p>
<p>In this dataset, some annotations are marked BA (body-anchored sign)
and others CL (classifier construction).</p>
<ul>
<li>BA stands for body-anchored sign, such as MAN, which has a specific
location on the body.<br />
</li>
<li>CL stands for classifier construction or a non-conventionalized
form, such as HAT-FLY AWAY.</li>
</ul>
<p>Because this data was annotated by humans, there are a few
inconsistencies. Our goal is to clean these up so that the annotation
labels are uniform and consistent.</p>
<p>The standard form is <code>BA-SIGN</code> (Body anchored) or
<code>CL-SIGN</code> (classifers).<br />
Yet, the data was full of errors such as: <code>BA -SIGN</code><br />
<code>BA - SIGN</code><br />
<code>BA- SIGN</code><br />
<code>BA SIGN</code><br />
<code>BA  SIGN</code><br />
<code>BA--SIGN</code><br />
<code>BA --SIGN</code><br />
<code>BA-- SIGN</code><br />
<code>BA -- SIGN</code></p>
<p>How do we write a regular expression to locate all of these errors
and the standard form?<br />
Make sure the <code>Regular Expression</code> checkbox is checked.</p>
<p><img src="RegEx_images/Elan_search.jpg" alt="ELAN search dialog" width="500"/></p>
<details>
<summary>
Click to reveal answer
</summary>
<p><strong><code>^BA *-* *</code></strong></p>
<p><code>^</code> (caret)<br />
– Start of the string or line. This means the match must begin right at
the start, not in the middle.)</p>
<p><code>BA</code><br />
– The literal letters <code>B</code> and <code>A</code>.<br />
— <code>^BA</code> Together they mean “find any string that starts with
<code>BA</code>.”</p>
<p><code>*</code> (space followed by *)<br />
– The space means “look for an actual space character”.<br />
– <code>*</code> means “zero or more of the preceding thing”.<br />
— Together: “Zero or more spaces”.<br />
— This allows matches even if there’s no space or multiple spaces after
BA.</p>
<p><code>-*</code> – The dash (<code>-</code>) is the literal hyphen
character.<br />
– <code>*</code> means zero or more of the preceding thing.<br />
— Together this means “zero or more hyphens”.<br />
— So far, this means it matches <code>BA</code> whether or not a hyphen
follows (e.g., <code>BA-</code>, <code>BA--</code>,
<code>BA</code>).</p>
<ul>
<li>(again)<br />
– Same as in step 2: zero or more spaces after the hyphen(s).</li>
</ul>
<p>In plain English, this means: Find any string that starts with
<code>BA</code>, optionally followed by spaces, optionally followed by
one or more hyphens, and optionally followed by spaces.</p>
</details>
<p><img src="RegEx_images/Elan_results.jpg" alt="Results of the search in ELAN" width="500"/></p>
<p>Replace the finding with <code>BA-</code>:<br />
<img src="RegEx_images/Elan_replace.jpg" alt="Results of the search in ELAN" width="200"/></p>
<p>Replacement results:<br />
<img src="RegEx_images/Elan_replace_results.jpg" alt="Results of the search in ELAN" width="500"/></p>
</div>
<div id="r-for-ipa" class="section level2" number="15.2">
<h2><span class="header-section-number">15.2</span> R for IPA</h2>
<div id="overview" class="section level3" number="15.2.1">
<h3><span class="header-section-number">15.2.1</span> Overview</h3>
<p>In this activity, we will use <strong>regular expressions</strong> to
convert Spanish orthography into <strong>broad IPA
transcription</strong>.<br />
We’ll work with Latin American Spanish (seseo, yeísmo).</p>
<p>We will attempt to transcribe the following words:<br />
<br> <em>queso</em>, ‘cheese’; <em>guitarra</em>, ‘guitar’;
<em>güiro</em>, ‘type of instrument’; <em>agua</em>, ‘water’;
<em>jefe</em>, ‘boss’; <em>niño</em>, ‘child’; <em>lluvia</em>, ‘rain’;
<em>casa</em>, ‘house’; <em>guerra</em>, ‘war’; <em>guapo</em>,
‘hansome’; <em>cerveza</em>, ‘beer’; <em>hablar</em>, ‘speak’;
<em>rey</em>, ‘king’; <em>arroyo</em>, ‘a dry stream’; <em>Yépez</em>,
‘a common last name’; <em>y</em>, ‘and’; <em>abierto</em> ‘open’,
<em>ambos</em> ‘both’</p>
<pre class="r"><code>x &lt;-c(&quot;queso&quot;, &quot;guitarra&quot;, &quot;güiro&quot;, &quot;agua&quot;, &quot;jefe&quot;,&quot;niño&quot;,&quot;lluvia&quot;, &quot;casa&quot;,&quot;guerra&quot;,&quot;guapo&quot;, &quot;cerveza&quot;, &quot;hablar&quot;, &quot;rey&quot;, &quot;arroyo&quot;, &quot;Yépez&quot;, &quot;y&quot;,&quot;abierto&quot;, &quot;ambos&quot;)</code></pre>
<p>Key teaching points:</p>
<ul>
<li><strong>Order matters</strong> — more specific patterns must be
replaced before more general ones.</li>
<li><strong>Phonology matters</strong> — for example, rhotics (/r/
vs. /ɾ/) require positional rules.</li>
</ul>
<hr />
<p><strong>R Code</strong></p>
<pre class="r"><code># Function: Convert orthographic Spanish to broad IPA
to_ipa &lt;- function(orth) {
  x &lt;- tolower(orth) # Converts all text to lowercase - very important!

#Note: `perl = TRUE` tells R to use the PCRE (Perl Compatible Regular Expressions) engine. This enables more advanced RegEx features like positive look ahead (?=) and positive look behind (?&lt;=).  

  # --- ORDER MATTERS: handle longer/more specific patterns first ---

  # 1) Affricates and digraphs
  x &lt;- gsub(&quot;ch&quot;, &quot;tʃ&quot;, x, perl = TRUE)    # ch → tʃ
  x &lt;- gsub(&quot;ll&quot;, &quot;ʎ&quot;, x, perl = TRUE)     # yeísmo: ll → ʝ; zheísmo: ll → ʒ 

  # 2) &#39;qu&#39; and &#39;c&#39; alternations (keep vowels)
  x &lt;- gsub(&quot;qu(?=[ieíé])&quot;, &quot;k&quot;, x, perl = TRUE)     # que/qui → ke/ki → k + vowel
  x &lt;- gsub(&quot;c(?=[ieíé])&quot;,  &quot;s&quot;, x, perl = TRUE)     # ce/ci → s (seseo)
  x &lt;- gsub(&quot;c&quot;,            &quot;k&quot;, x, perl = TRUE)     # ca/co/cu → k

  # 3) g/j: velar fricative /x/ before e,i; hard g elsewhere
  x &lt;- gsub(&quot;gü&quot;,  &quot;gw&quot;, x, perl = TRUE)             # güe/güi → gwe/gwi
  x &lt;- gsub(&quot;gue&quot;, &quot;ge&quot;, x, perl = TRUE)             # silent u
  x &lt;- gsub(&quot;gui&quot;, &quot;gi&quot;, x, perl = TRUE)             # silent u
  
  x &lt;- gsub(&quot;j&quot;, &quot;x&quot;, x, perl = TRUE)                # j → x

  # 4) Cluster simplification
  x &lt;- gsub(&quot;gua&quot;, &quot;wa&quot;, x, perl = TRUE)             # agua → awa

  # 5) z and b/v neutralization
  x &lt;- gsub(&quot;z&quot;,  &quot;s&quot;, x, perl = TRUE)               # seseo: z → s
  x &lt;- gsub(&quot;[bv]&quot;, &quot;b&quot;, x, perl = TRUE)             # b and v merge (b isn&#39;t necessary but deal)

  # 6) ñ, y (consonantal), h
  x &lt;- gsub(&quot;ñ&quot;, &quot;ɲ&quot;, x, perl = TRUE)
  x &lt;- gsub(&quot;(?&lt;=[aeiouáéíóú])y(?=[aeiouáéíóú])&quot;, &quot;ʎ&quot;, x, perl = TRUE) #?&lt;= positive look behind, ?= positive look ahead
    x &lt;- gsub(&quot;(?&lt;=[a-záéíóú])b(?=[a-záéíóú])&quot;, &quot;β&quot;, x, perl = TRUE) #?&lt;= positive look behind, ?= positive look ahead
    x &lt;- gsub(&quot;(?&lt;=[mn])β&quot;, &quot;b&quot;, x, perl = TRUE) #?&lt;= positive look behind, ?= positive look ahead
    
  x &lt;- gsub(&quot;^y(?=[aeiouáéíóú])&quot;, &quot;ʎ&quot;, x, perl = TRUE)
  x &lt;- gsub(&quot;y\\b&quot;, &quot;i&quot;, x, perl = TRUE)
  x &lt;- gsub(&quot;h&quot;, &quot;&quot;, x, perl = TRUE)

  # 8) Rhotics — do last
  x &lt;- gsub(&quot;r&quot;, &quot;ɾ&quot;, x, perl = TRUE)                 # elsewhere → tap
  x &lt;- gsub(&quot;ɾɾ&quot;, &quot;r&quot;, x, perl = TRUE)                # trill
  x &lt;- gsub(&quot;^ɾ&quot;, &quot;r&quot;, x, perl = TRUE)                # word-initial

  x
}

# Example data
words &lt;- c(&quot;queso&quot;, &quot;guitarra&quot;, &quot;güiro&quot;, &quot;agua&quot;, &quot;jefe&quot;,&quot;niño&quot;,&quot;lluvia&quot;, &quot;casa&quot;,&quot;guerra&quot;,&quot;guapo&quot;, &quot;cerveza&quot;, &quot;hablar&quot;, &quot;rey&quot;, &quot;arroyo&quot;, &quot;Yépez&quot;, &quot;y&quot;, &quot;abierto&quot;, &quot;ambos&quot;)
to_ipa(words)</code></pre>
<pre><code>##  [1] &quot;keso&quot;    &quot;gitara&quot;  &quot;gwiɾo&quot;   &quot;awa&quot;     &quot;xefe&quot;    &quot;niɲo&quot;    &quot;ʎuβia&quot;  
##  [8] &quot;kasa&quot;    &quot;gera&quot;    &quot;wapo&quot;    &quot;seɾβesa&quot; &quot;aβlaɾ&quot;   &quot;rei&quot;     &quot;aroʎo&quot;  
## [15] &quot;ʎépes&quot;   &quot;i&quot;       &quot;aβieɾto&quot; &quot;ambos&quot;</code></pre>
</div>
</div>
</div>
<div id="homework" class="section level1" number="16">
<h1><span class="header-section-number">16</span> Homework</h1>
<p>Convert this JSON file to a wordlist using RegEx. Show your
work.<br />
<a href="Dictionary.txt">Dictionary.txt</a><br />
Results should look like this:<br />
<code>coluhua</code><br />
<code>curiusu</code><br />
<code>dirichu</code></p>
<p>Now with the following orthography-to-IPA conversions, create a new
column with the IPA transcriptions of each word.</p>
<p><code>ñ→ɲ</code><br />
<code>ngue→ngi</code><br />
<code>ryn→ɾin</code><br />
<code>hua→wa</code><br />
<code>gua→wa</code><br />
<code>gue→we</code><br />
<code>ch→ʧ</code><br />
<code>sh→ʃ</code><br />
<code>ll→ʒ</code><br />
<code>(rr|^r)→@</code><br />
<code>r→ɾ</code><br />
<code>@→ʐ</code><br />
<code>ɾ$→ɾ</code><br />
<code>cona→kuna</code><br />
<code>ce→se</code><br />
<code>ci→si</code><br />
<code>ca→ka</code><br />
<code>co→ko</code><br />
<code>cc→ks</code><br />
<code>cu→ku</code><br />
<code>cpi→kpi</code><br />
<code>c→k</code><br />
<code>cʒ→kʒ</code><br />
<code>cl→kl</code><br />
<code>ct→kt</code><br />
<code>cʧ→kʧ</code><br />
<code>cʧ→kʧ</code><br />
<code>cs→ks</code><br />
<code>cr→kɾ</code><br />
<code>cɾ→kɾ</code><br />
<code>qu→k</code><br />
<code>x→ks</code><br />
<code>hu→xu</code><br />
<code>gui→gi</code><br />
<code>j→x</code><br />
<code>-y-→ i</code><br />
<code>y→ i</code><br />
<code>y→i</code><br />
<code>y$→i</code><br />
<code>ɾy→ɾi</code><br />
<code>my→mi</code><br />
<code>me→mi</code><br />
<code>chon→ʧun</code><br />
<code>nosotɾoʃpa→nosotɾospa</code><br />
<code>spata→ʃpata</code><br />
<code>spami→ʃpami</code><br />
<code>spame→ʃpami</code><br />
<code>ny→ni</code><br />
<code>mary→maɾi</code><br />
<code>chy→ʧi</code><br />
<code>py→pi</code><br />
<code>y→j</code><br />
<code>by→bi</code><br />
<code>nguy→ngi</code><br />
<code>gry→gɾi</code><br />
<code>shy→ʃi</code><br />
<code>chary→ʧaɾi</code><br />
<code>siky→siki</code><br />
<code>niky→niki</code><br />
<code>kuty→kuti</code><br />
<code>^v→b</code><br />
<code>v→b</code><br />
<code>v→β</code><br />
<code>^z→s</code><br />
<code>z→s</code><br />
<code>ts→z</code><br />
<code>tz→z</code><br />
<code>aj→ai</code><br />
<code>aw→au</code><br />
<code>aia→aja</code><br />
<code>ajai→aiai</code><br />
<code>aua→awa</code><br />
<code>auo→awo</code><br />
<code>aue→awe</code><br />
<code>aiu→aiu</code><br />
<code>aui→awi</code><br />
<code>aie→aje</code><br />
<code>í→i</code><br />
<code>é→e</code><br />
<code>á→a</code><br />
<code>ó→o</code><br />
<code>ú→u</code><br />
<code>g→g</code><br />
<code>weɾba→geɾba</code><br />
<code>wiɾba→giɾba</code><br />
<code>(\\(|\\)|-|_|h|\\.|,|;|¿|!|\\?|'||\\|¡|\\[|\\]|\n)→</code></p>
<p><strong>No credit will be given for manual list creation or copying
the IPA from the JSON file</strong></p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
